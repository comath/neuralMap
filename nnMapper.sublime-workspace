{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"D",
				"DDEBUG"
			],
			[
				"pr",
				"printFloatArr"
			],
			[
				"in",
				"inDim"
			],
			[
				"qr",
				"qr_null"
			],
			[
				"nu",
				"null"
			],
			[
				"vec",
				"vec2"
			],
			[
				"id",
				"idMat"
			],
			[
				"la",
				"label"
			],
			[
				"l",
				"label"
			],
			[
				"lab",
				"labels"
			],
			[
				"da",
				"dataBySig"
			],
			[
				"po",
				"possibleSig"
			],
			[
				"sub",
				"subPlots"
			],
			[
				"data",
				"dataBysig"
			],
			[
				"ip",
				"ipSignature"
			],
			[
				"c",
				"chromaSig"
			],
			[
				"dr",
				"drawSig"
			],
			[
				"con",
				"convertToRGB"
			],
			[
				"ca",
				"cache"
			],
			[
				"lo",
				"locationTree"
			],
			[
				"nn",
				"nnMap"
			],
			[
				"mapp",
				"mapperDataDestroy"
			],
			[
				"mapper",
				"mapperDataCreator"
			],
			[
				"th",
				"threshhold"
			],
			[
				"test",
				"testChromaticKey"
			],
			[
				"arr",
				"arrLength"
			],
			[
				"next",
				"nextDist"
			],
			[
				"cur",
				"curDist"
			],
			[
				"print",
				"printf\tprintf …"
			],
			[
				"pri",
				"printf\tprintf …"
			],
			[
				"key",
				"keyLength"
			],
			[
				"prin",
				"printKeyArr"
			],
			[
				"ke",
				"keyLen"
			],
			[
				"num",
				"numData"
			],
			[
				"if",
				"ifdef"
			],
			[
				"hp",
				"hpOffsetVecs"
			],
			[
				"cb",
				"cblas_scopy"
			],
			[
				"v",
				"vt"
			],
			[
				"out",
				"outDim"
			],
			[
				"ky",
				"keyLength"
			],
			[
				"cu",
				"curSmallestIndex"
			],
			[
				"p",
				"printf\tprintf …"
			],
			[
				"int",
				"int32"
			],
			[
				"ma",
				"maxThreads"
			],
			[
				"er",
				"eprint"
			],
			[
				"mk",
				"mklLibDir"
			],
			[
				"mkl",
				"mklRootDir"
			],
			[
				"ut",
				"utilsDir"
			],
			[
				"cython",
				"cythonize"
			],
			[
				"e",
				"evalLayer"
			],
			[
				"nd",
				"ndarray"
			],
			[
				"Ou",
				"outDim"
			],
			[
				"fre",
				"freeCache"
			],
			[
				"cal",
				"calcKeyLen"
			],
			[
				"ipCa",
				"ipCalculator"
			],
			[
				"siz",
				"keySize"
			],
			[
				"m",
				"myargs"
			],
			[
				"ra",
				"randomData"
			],
			[
				"layr",
				"layer0"
			],
			[
				"MKL",
				"MKL_INT"
			],
			[
				"MK",
				"MKL_INT"
			],
			[
				"li",
				"linearAlgebra"
			],
			[
				"pa",
				"paralleltree_test"
			],
			[
				"Tes",
				"testRebuildKey"
			],
			[
				"te",
				"testKey"
			],
			[
				"re",
				"RecreateArr"
			],
			[
				"DA",
				"DATASIZE"
			],
			[
				"tes",
				"testKey"
			],
			[
				"com",
				"compareArr"
			],
			[
				"t",
				"testKey2"
			],
			[
				"DATA",
				"DATASIZE"
			],
			[
				"de",
				"define"
			],
			[
				"ar",
				"arrLength"
			],
			[
				"my",
				"myInput"
			],
			[
				"big",
				"bigspinlock"
			],
			[
				"dat",
				"dataInput"
			],
			[
				"ret",
				"returnArr"
			],
			[
				"val",
				"value"
			],
			[
				"n",
				"numElements"
			],
			[
				"error",
				"errorCount"
			],
			[
				"tot",
				"totalValue"
			],
			[
				"to",
				"totalCount"
			],
			[
				"total",
				"totalCount"
			],
			[
				"no",
				"numToAdd"
			],
			[
				"tr",
				"treeDepth"
			],
			[
				"a",
				"allocateTree"
			],
			[
				"par",
				"parentNode"
			],
			[
				"thre",
				"thread_args"
			],
			[
				"pthe",
				"pthread_spinlock_t"
			],
			[
				"i",
				"include"
			],
			[
				"tre",
				"treeDepth"
			],
			[
				"Tree",
				"TreeNode"
			],
			[
				"Tr",
				"treeDepth"
			],
			[
				"tree",
				"treeDepth"
			],
			[
				"mu",
				"muttarr"
			],
			[
				"ve",
				"vectorAddThreadArgs"
			],
			[
				"rand",
				"randArr"
			],
			[
				"ran",
				"randArr"
			],
			[
				"ther",
				"thread_args"
			],
			[
				"node",
				"nodeBig"
			],
			[
				"sma",
				"smallNode"
			],
			[
				"pthread",
				"pthread_mutex_t"
			],
			[
				"pth",
				"pthread_mutex_t"
			],
			[
				"resha",
				"reshapedInputs"
			],
			[
				"inp",
				"inputs"
			],
			[
				"ou",
				"outputLayer"
			],
			[
				"lay",
				"layer2"
			],
			[
				"hi",
				"hiddenDim2"
			],
			[
				"sig",
				"sigmoidalLayer"
			],
			[
				"si",
				"sigmoidalLayer"
			],
			[
				"rank",
				"rankRange"
			]
		]
	},
	"buffers":
	[
		{
			"file": "source/cutils/ipCalculator.h",
			"settings":
			{
				"buffer_size": 667,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include \"ipCalculator.h\"\n#include <float.h>\n\n#include <mkl.h>\n#include <mkl_cblas.h>\n#include <mkl_blas.h>\n#include <mkl_lapack.h>\n#include <mkl_lapacke.h>\n\n\n\ntypedef struct ipCacheInput {\n\t//This should be a constant\n\tconst ipCache * info;\n\t//This shouldn't be\n\tuint *key;\n} ipCacheInput;\n\ntypedef struct ipCacheData {\n\tfloat *solution;\n\tfloat *projection;\n} ipCacheData;\n\n/*\n This can only handle neural networks whose input dimension is greater than the number of nodes in the first layer\n*/\nstruct ipCacheData * solve(float *A, MKL_INT outDim, MKL_INT inDim, float *b)\n{\t\n\t#ifdef DEBUG\n\t\tprintf(\"------------------Solve--------------\\n\");\n\t\tprintf(\"The dimensions are inDim: %u, outDim: %d \\n\", inDim, outDim);\n\t#endif\n\tMKL_INT info;\n\tMKL_INT minMN = ((inDim)>(outDim)?(outDim):(inDim));\n\tfloat *superb = calloc(minMN, sizeof(float)); \n\t/* Local arrays */\n\tfloat *s = calloc(inDim,sizeof(float)); // Diagonal entries\n\tfloat *u = calloc(outDim*outDim , sizeof(float));\n\tfloat *vt = calloc(inDim*inDim, sizeof(float));\n\tstruct ipCacheData *output = malloc(sizeof(struct ipCacheData));\n\n\n\t/* Executable statements */\n\tinfo = LAPACKE_sgesvd( LAPACK_ROW_MAJOR, 'A', 'A'\n\t\t\n\t\t\t\t\t\t  outDim, inDim, A, inDim,\n\t\t    \t\t\t  s, u, outDim,\n\t\t    \t\t\t  vt, inDim,\n\t\t    \t\t\t  superb);\n\t// Incase of memory leaks:\n\t//mkl_thread_free_buffers();\n\tif( info > 0 ) {\n\t\tprintf( \"The algorithm computing SVD failed to converge.\\n\" );\n\t\texit( 1 );\n\t}\n\n\n\t// Multiplying Sigma+t with u\n\tint i = 0;\n\tfor(i=0;i<outDim;i++){\n\t\tcblas_sscal(outDim,(1/s[i]),u+i*outDim,1);\n\t}\n\t\t \n\tfloat *solution = calloc(inDim, sizeof(float));\n\tfloat *c = calloc(inDim*outDim, sizeof(float));\n\t#ifdef DEBUG\n\t\tif(inDim < 10 && outDim < 20){\n\t\t\tprintf(\"U:\\n\");\n\t\t\tprintMatrix(u,outDim,outDim);\n\t\t\tprintf(\"Diagonal entries of S:\\n\");\n\t\t\tprintFloatArr(s,minMN);\n\t\t\tprintf(\"V^T:\\n\");\n\t\t\tprintMatrix(vt,inDim,inDim);\n\t\t}\n\t\tprintf(\"Multiplying u sigma+t with vt\\n\");\n\t#endif\n\t// Multiplying u sigma+t with vt\n\tcblas_sgemm (CblasRowMajor, CblasNoTrans, CblasNoTrans,\n\t\t\t\toutDim, inDim, outDim, 1, u,\n\t\t\t\toutDim, vt, inDim,\n\t\t\t\t0,c, inDim);\n\t#ifdef DEBUG\n\t\tif(inDim < 10 && outDim < 20){\n\t\t\tprintf(\"Result of the previous multiplication:\\n\");\n\t\t\tprintMatrix(c,inDim,outDim);\n\t\t\tprintf(\"b:\");\n\t\t\tprintFloatArr(b,outDim);\n\t\t}\n\t\tprintf(\"Multiplying v sigma+ u with b for the solution \\n\");\n\t\t\n\t#endif\n\t// Multiplying v sigma+ u with b for the solution\t\t\t\t\\/ param 7\n\tcblas_sgemv (CblasRowMajor, CblasTrans, inDim, outDim,1, c, outDim, b, 1, 0, solution, 1);\n\t#ifdef DEBUG\n\t\tprintf(\"Result of the previous multiplication:\\n\");\n\t\tif(inDim < 10){\n\t\t\tprintFloatArr(solution,inDim);\n\t\t}\n\t\t\n\t#endif\n\t// Saving the kernel basis from vt\n\tif(outDim<inDim){\n\t\toutput->projection = calloc(inDim*inDim,sizeof(float));\n\t\t#ifdef DEBUG\n\t\t\tprintf(\"Multiplying the first %u rows of vt for the projection\\n\", outDim);\n\t\t#endif\n\n\t\tcblas_sgemm (CblasRowMajor, CblasTrans, CblasNoTrans,\n\t\t\t\t\toutDim, outDim, (inDim-outDim), 1, vt+inDim*outDim,outDim, \n\t\t\t\t\tvt+inDim*outDim, inDim,\n\t\t\t\t\t0, output->projection, outDim);\n\t} else {\n\t\toutput->projection = NULL;\n\t}\n\tfree(s);\n\tfree(u);\n\tfree(vt);\n\tfree(c);\n\tfree(superb);\n\t// Incase of memory leaks:\n\t//mkl_thread_free_buffers();\n\n\toutput->solution = solution;\n\t#ifdef DEBUG\n\t\tprintf(\"-----------------/Solve--------------\\n\");\n\t#endif\n\treturn output;\n}\n\nvoid * ipCacheDataCreator(void * input)\n{\n\tstruct ipCacheInput *myInput;\n\tmyInput = (struct ipCacheInput *) input;\n\tnnLayer *layer0 = myInput->info->layer0;\n\n\tuint inDim = layer0->inDim;\n\tuint outDim = layer0->outDim;\n\n\tfloat *subA = calloc(inDim*outDim, sizeof(float));\n\tfloat *subB = calloc(outDim,sizeof(float));\n\tuint i = 0;\n\tuint numHps = 0;\n\tfor(i=0;i<inDim;i++){\n\t\tif(checkIndex(myInput->key,i)){\n\t\t\tcblas_scopy (inDim, layer0->A +i*inDim, 1, subA + numHps*inDim, 1);\n\t\t\tsubB[numHps] = layer0->b[i];\n\t\t\tnumHps++;\n\t\t}\n\t}\n\t//If there's less included hyperplanes there will be a kernel\n\tif(numHps <= inDim){\n\t\tMKL_INT m = numHps;\n\t\tMKL_INT n = inDim;\n\t\tipCacheData *ret = solve(subA, m, n, subB);\n\t\tfree(subA);\n\t\tfree(subB);\n\t\treturn ret;\n\t} else {\n\t\tfree(subA);\n\t\tfree(subB);\n\t\treturn NULL;\n\t}\n}\nvoid ipCacheDataDestroy(void * data)\n{\n\tstruct ipCacheData *myData;\n\tmyData = (struct ipCacheData *) data;\n\tif(myData){\n\t\tif(myData->projection){\n\t\t\tfree(myData->projection);\n\t\t}\n\t\tif(myData->solution){\n\t\t\tfree(myData->solution);\n\t\t}\n\t\tfree(myData);\n\t}\n}\n\nvoid createHPCache(ipCache *cache)\n{\n\t\n\tuint i = 0;\n\tnnLayer *layer0 = cache->layer0;\n\tuint inDim = layer0->inDim;\n\tuint outDim = layer0->outDim;\n\n\tcache->hpNormals = calloc(outDim*inDim,sizeof(float));\n\tcache->hpOffsetVecs = calloc(outDim*inDim,sizeof(float));\n\n\tfloat scaling = 1;\n\t#ifdef DEBUG\n\t\tprintf(\"--------createHPCache-------------\\n\");\n\t\tprintf(\"inDim: %u\\n\", inDim);\n\t\tprintf(\"outDim: %u\\n\", outDim);\n\t#endif\n\tfor(i=0;i<outDim;i++){\n\t\t#ifdef DEBUG\n\t\t\tprintf(\"----%u----\\n\",i);\n\t\t\tif(inDim < 10){\n\t\t\t\tprintf(\"Hyperplane vector: \");\n\t\t\t\tprintFloatArr(layer0->A + inDim*i,inDim);\n\t\t\t}\n\t\t\tprintf(\"Offset Value: %f\\n\",layer0->b[i]);\t\t\t\n\t\t#endif\t\n\t\tscaling = cblas_snrm2 (inDim, layer0->A + inDim*i, 1);\n\t\tif(scaling){\n\t\t\tcblas_saxpy (inDim,1/scaling,layer0->A + inDim*i,1,cache->hpNormals + inDim*i,1);\n\t\t\tcblas_saxpy (inDim,layer0->b[i]/scaling,cache->hpNormals+inDim*i,1,cache->hpOffsetVecs + inDim*i,1);\n\t\t\t#ifdef DEBUG\n\t\t\t\tprintf(\"Scaling factor (norm of hyperplane vector): %f\\n\",scaling);\n\t\t\t\t\n\t\t\t\tif(inDim < 10){\n\t\t\t\t\tprintf(\"Normalized normal vector: \");\n\t\t\t\t\tprintFloatArr(cache->hpNormals + i*inDim,inDim);\n\t\t\t\t\tprintf(\"Offset vector: \");\n\t\t\t\t\tprintFloatArr(cache->hpOffsetVecs+ i*inDim,inDim);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t#endif\n\t\t} else {\n\t\t\t// HP normals has length 0, thus it is 0. The offset vector should also be 0\n\t\t\tcblas_scopy(inDim,cache->hpNormals+i*inDim,1,cache->hpOffsetVecs+i*inDim,1);\n\t\t}\n\t}\n\t#ifdef DEBUG\n\t\tprintf(\"---------------------------------\\n\");\n\t#endif\n}\n\nipCache * allocateCache(nnLayer *layer0, float threshhold)\n{\n\tipCache *cache = malloc(sizeof(ipCache));\n\tuint keyLen = calcKeyLen(layer0->outDim);\n\tcache->bases = createTree(8,keyLen , ipCacheDataCreator, NULL, ipCacheDataDestroy);\n\n\tprintf(\"Creating cache of inDim %d and outDim %d with threshhold %f \\n\", layer0->inDim, layer0->outDim, threshhold);\n\t#ifdef DEBUG\n\t\tprintf(\"-----------------allocateCache--------------------\\n\");\n\t\tif(layer0->inDim < 10 && layer0->outDim <20){\n\t\t\tprintf(\"The matrix is: \\n\");\n\t\t\tprintMatrix(layer0->A,layer0->inDim,layer0->outDim);\n\t\t\tprintf(\"The offset vector is: \");\n\t\t\tprintFloatArr(layer0->b, layer0->outDim);\n\t\t}\n\t#endif\n\tcache->layer0 = layer0;\n\tcreateHPCache(cache);\n\tcache->threshold = threshhold;\n\t#ifdef DEBUG\n\t\tprintf(\"--------------------------------------------------\\n\");\n\t#endif\n\treturn cache;\n}\n\nvoid freeCache(ipCache * cache)\n{\n\tif(cache){\n\t\tprintf(\"Cache exists, deallocating\\n\");\n\t\tfreeTree(cache->bases);\n\t\tif(cache->hpOffsetVecs){\n\t\t\tfree(cache->hpOffsetVecs);\n\t\t}\n\t\tif(cache->hpNormals){\n\t\t\tfree(cache->hpNormals);\n\t\t}\n\t\tfree(cache);\n\t}\n}\n\n\nfloat computeDist(float * p, uint *ipSignature, ipCache *cache)\n{\n\n\tipCacheInput myInput = {.info = cache, .key = ipSignature};\n\tstruct ipCacheData *myBasis = addData(cache->bases, ipSignature, &myInput);;\n\t\n\tif(myBasis){\n\t\tMKL_INT inDim = cache->layer0->inDim;\n\t\tfloat * px = malloc(inDim * sizeof(float));\n\t\tcblas_scopy (inDim, p, 1, px, 1);\n\t\tcblas_saxpy (inDim,1,myBasis->solution,1,px,1);\n\t\tcblas_sgemv (CblasRowMajor, CblasNoTrans, inDim, inDim,-1,myBasis->projection, inDim, px, 1, 1, px, 1);\n\t\tfloat norm = cblas_snrm2 (inDim, px, 1);\n\t\tif(norm < 0){\n\t\t\tnorm = -norm;\n\t\t}\n\t\tfree(px);\n\t\treturn norm;\n\t} else {\n\t\treturn -1;\n\t}\t\n}\n\nvoid computeDistToHPS(float *p, ipCache *cache, float *distances)\n{\n\tuint outDim = cache->layer0->outDim;\n\tuint inDim = cache->layer0->inDim;\n\tfloat * localCopy = calloc(outDim*inDim,sizeof(float));\n\tcblas_scopy (inDim*outDim, cache->hpOffsetVecs, 1, localCopy, 1);\n\t\n\t#ifdef DEBUG\n\t\tprintf(\"--------computeDistToHPS---------\\n\");\n\t#endif\n\tfor(uint i =0;i<outDim;++i){\n\t\t#ifdef DEBUG\n\t\t\tprintf(\"----%d----\\n\",i);\n\t\t\tif(inDim < 10){\n\t\t\t\tprintf(\"Point were taking the distance to: \");\n\t\t\t\tprintFloatArr(p,inDim);\n\t\t\t\tprintf(\"Copied over the offset vectors: \");\n\t\t\t\tprintFloatArr(localCopy + i*inDim,inDim);\n\t\t\t\tprintf(\"Original offset vectors: \");\n\t\t\t\tprintFloatArr(cache->hpOffsetVecs+ i*inDim,inDim);\n\t\t\t\tprintf(\"Normal Vectors: \");\n\t\t\t\tprintFloatArr(cache->hpNormals + i*inDim,inDim);\n\t\t\t}\n\t\t#endif\n\t\tcblas_saxpy (inDim,1,p,1,localCopy + i*inDim,1);\n\t\tdistances[i] = cblas_sdot (inDim, localCopy + i*inDim, 1, cache->hpNormals + i*inDim, 1);\n\t\tif(distances[i] < 0){\n\t\t\tdistances[i] = -distances[i];\n\t\t}\n\t\tif(distances[i] == 0){\n\t\t\t// Sometimes the normal vector is 0, ie, this hyperplane is not used\n\t\t\t// We check for this, and if so, essentially remove this distance from the situation.\n\t\t\tfloat norm = cblas_snrm2 (inDim, cache->hpNormals + i*inDim, 1);\n\t\t\tif(norm == 0){\n\t\t\t\tdistances[i] = FLT_MAX;\n\t\t\t} else {\n\t\t\t\tdistances[i] = 0;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t#ifdef DEBUG\n\t\t\tprintf(\"p + offset vector: \");\n\t\t\tif(inDim < 10){\n\t\t\t\tprintFloatArr(localCopy+i*inDim,inDim);\n\t\t\t}\n\t\t\tif(distances[i] == FLT_MAX){\n\t\t\t\tprintf(\"Final distance is massive as the hp does not exist\\n\");\n\t\t\t} else {\n\t\t\t\tprintf(\"Final distance (normal dotted with p+offset): %f \\n\",distances[i]);\n\t\t\t}\n\t\t\tprintf(\"---------\\n\");\n\t\t#endif\n\t}\n\t#ifdef DEBUG\n\t\tprintf(\"---------------------------------\\n\");\n\t#endif\n\tfree(localCopy);\n}\n\n\nvoid getInterSig(ipCache * cache, float *p, uint *ipSignature)\n{\n\t// Prepare all the internal values and place commonly referenced ones on the stack\n\tuint outDim = cache->layer0->outDim;\n\tuint inDim = cache->layer0->inDim;\n\tuint keyLength = cache->bases->keyLength;\n\tclearKey(ipSignature,keyLength);\n\tuint j = 1;\n\n\t// Compute the distances to all the hyperplanes.\n\tfloat *distances = calloc(outDim,sizeof(float));\n\tcomputeDistToHPS(p, cache, distances);\n\t\t\n\n\t#ifdef DEBUG\n\t\tprintf(\"--------------------------getInterSig-----------------------------------------------\\n\");\n\t\tprintf(\"Aquiring the ipSignature of \");\n\t\tif(inDim < 10){\n\t\t\tprintFloatArr(p,inDim);\n\t\t}\n\t\tprintf(\"The distances to the hyperplanes are \");\n\t\tif(outDim < 15){\n\t\t\tprintFloatArr(distances,outDim);\n\t\t}\n\t#endif\n\t\n\t// Get the distance to the closest hyperplane and blank it from the distance array\n\tuint curSmallestIndex = cblas_isamin (outDim, distances, 1);\n\tfloat curDist = distances[curSmallestIndex];\n\tdistances[curSmallestIndex] = FLT_MAX;\n\taddIndexToKey(ipSignature, curSmallestIndex);\n\n\t#ifdef DEBUG\n\t\tprintf(\"The closest hyperplane is %u and is %f away.\\n\", curSmallestIndex,curDist);\n\t\tprintf(\"After adding index %u the key is now: \", curSmallestIndex);\n\t\tprintKey(ipSignature,outDim);\n\t#endif\n\n\t// Get the distance to the second closest hyperplane and blank it\n\tcurSmallestIndex = cblas_isamin (outDim, distances, 1);\n\tfloat nextDist = distances[curSmallestIndex];\n\tdistances[curSmallestIndex] = FLT_MAX;\n\n\t#ifdef DEBUG\n\t\tprintf(\"The second closest hyperplane is %u and is %f away.\\n\", curSmallestIndex,nextDist);\n\t\tif(!(curDist>0 && nextDist < cache->threshold*curDist && j < inDim)){\n\t\t\tprintf(\"\\t This does not satisfy the condition.\\n\");\n\t\t}\n\t#endif\n\n\t// The main loop\n\twhile(curDist>0 && nextDist < cache->threshold*curDist && j < inDim)\n\t{\t\n\t\taddIndexToKey(ipSignature, curSmallestIndex);\n\t\t#ifdef DEBUG\n\t\t\tprintf(\"----While Loop %u----\\n\", j);\n\t\t\tprintf(\"Current Distance is %f, nextDist is %f\\n\", curDist, nextDist);\n\t\t\tprintf(\"Adding %u to the ipSignature and finding the distance to the associated intersection\\n\",curSmallestIndex);\n\t\t\tprintf(\"The unfurled interSig is \");\n\t\t\tprintKey(ipSignature,outDim);\n\t\t#endif\n\t\t\n\t\t// Prepare for next loop\n\t\tcurSmallestIndex = cblas_isamin (outDim, distances, 1);\n\t\t// Current distance should be the distance to the current IP set\n\t\tcurDist = computeDist(p, ipSignature, cache);\n\n\t\t// Next distance should either be to the next hyperplane or the next closest IP of the same rank.\n\t\tnextDist = distances[curSmallestIndex];\n\t\tdistances[curSmallestIndex] = FLT_MAX;\n\n\t\t\n\t\tj++;\n\t}\n\t#ifdef DEBUG\n\t\tprintf(\"Main While Loop Completed\\n\");\n\t\tprintf(\"The raw interSig is (in key form)\");\n\t\tprintKeyArr(ipSignature,keyLength);\n\t\tprintf(\"The unfurled interSig is \");\n\t\tprintKey(ipSignature,outDim);\n\t\tprintf(\"--------------------------/getInterSig-----------------------------------------------\\n\");;\n\t#endif\n\tfree(distances);\n}\n\nstruct IPAddThreadArgs {\n\tuint tid;\n\tuint numThreads;\n\n\tuint numData;\n\tfloat * data;\n\tuint *ipSignature;\n\n\tipCache *cache;\n};\n\nvoid * addIPBatch_thread(void *thread_args)\n{\n\tstruct IPAddThreadArgs *myargs;\n\tmyargs = (struct IPAddThreadArgs *) thread_args;\n\n\tuint tid = myargs->tid;\t\n\tuint numThreads = myargs->numThreads;\n\n\tuint numData = myargs->numData;\n\tfloat *data = myargs->data;\n\tuint *ipSignature = myargs->ipSignature;\n\n\tipCache *cache = myargs->cache;\n\n\tuint dim = cache->layer0->inDim;\n\tuint keySize = calcKeyLen(cache->layer0->outDim);\n\n\tuint i = 0;\n\tfor(i=tid;i<numData;i=i+numThreads){\t\t\n\t\tgetInterSig(cache,data+i*dim, ipSignature+i*keySize);\n\t}\n\tpthread_exit(NULL);\n}\n\nvoid getInterSigBatch(ipCache *cache, float *data, uint *ipSignature, uint numData, uint numProc)\n{\n\tint maxThreads = numProc;\n\tint rc =0;\n\tint i =0;\n\t//printf(\"Number of processors: %d\\n\",maxThreads);\n\t//Add one data to the first node so that we can avoid the race condition.\n\t\n\n\tstruct IPAddThreadArgs *thread_args = malloc(maxThreads*sizeof(struct IPAddThreadArgs));\n\n\tpthread_t threads[maxThreads];\n\tpthread_attr_t attr;\n\tvoid *status;\n\tpthread_attr_init(&attr);\n\tpthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n\t\n\tfor(i=0;i<maxThreads;i++){\n\t\tthread_args[i].cache = cache;\n\t\tthread_args[i].numData = numData;\n\t\tthread_args[i].ipSignature = ipSignature;\n\t\tthread_args[i].data = data;\n\t\tthread_args[i].numThreads = maxThreads;\n\t\tthread_args[i].tid = i;\n\t\trc = pthread_create(&threads[i], NULL, addIPBatch_thread, (void *)&thread_args[i]);\n\t\tif (rc){\n\t\t\tprintf(\"Error, unable to create thread\\n\");\n\t\t\texit(-1);\n\t\t}\n\t}\n\n\tfor( i=0; i < maxThreads; i++ ){\n\t\trc = pthread_join(threads[i], &status);\n\t\tif (rc){\n\t\t\tprintf(\"Error, unable to join: %d \\n\", rc);\n\t\t\texit(-1);\n     \t}\n\t}\n\n\tfree(thread_args);\n}",
			"file": "source/cutils/ipCalculator.c",
			"file_size": 14140,
			"file_write_time": 131308827298490029,
			"settings":
			{
				"buffer_size": 14142,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "log.txt",
			"settings":
			{
				"buffer_size": 593592,
				"line_ending": "Unix"
			}
		},
		{
			"file": "source/test/mapper_test.py",
			"settings":
			{
				"buffer_size": 2871,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "source/pythonInterface/buildMapperWrap.py",
			"settings":
			{
				"buffer_size": 1326,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "source/cutils/mapper.h",
			"settings":
			{
				"buffer_size": 986,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "source/cutils/mapper.c",
			"settings":
			{
				"buffer_size": 6612,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "source/cutils/parallelTree.c",
			"settings":
			{
				"buffer_size": 5093,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "source/cutils/key.c",
			"settings":
			{
				"buffer_size": 3132,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "source/test/ipCalculator_test.py",
			"settings":
			{
				"buffer_size": 2047,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "makefile",
			"settings":
			{
				"buffer_size": 2726,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "source/pythonInterface/keyWrap.pyx",
			"settings":
			{
				"buffer_size": 1603,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "source/pythonInterface/ipCalculatorWrap.pyx",
			"settings":
			{
				"buffer_size": 4459,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "source/cutils/nnLayerUtils.c",
			"settings":
			{
				"buffer_size": 1701,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
		[
			[
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					""
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"Traditional"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"PdfLaTeX"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"XeLaTeX"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"LuaLaTeX"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"Basic Builder"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"Basic Builder - PdfLaTeX"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"Basic Builder - XeLaTeX"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"Basic Builder - LuaLaTeX"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"Script Builder"
				]
			],
			[
				"Packages/LaTeXTools/LaTeX.sublime-build",
				""
			]
		],
		[
			[
				[
					"Packages/Makefile/Make.sublime-build",
					""
				],
				[
					"Packages/Makefile/Make.sublime-build",
					"Clean"
				],
				[
					"Packages/Python/Python.sublime-build",
					""
				],
				[
					"Packages/Python/Python.sublime-build",
					"Syntax Check"
				]
			],
			[
				"Packages/Python/Python.sublime-build",
				""
			]
		],
		[
			[
				[
					"Packages/Python/Python.sublime-build",
					""
				],
				[
					"Packages/Python/Python.sublime-build",
					"Syntax Check"
				]
			],
			[
				"Packages/Python/Python.sublime-build",
				""
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 174.0,
		"last_filter": "instal",
		"selected_items":
		[
			[
				"instal",
				"Package Control: Install Package"
			],
			[
				"isntal",
				"Install Package Control"
			]
		],
		"width": 414.0
	},
	"console":
	{
		"height": 126.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/sven/code/nnMapper",
		"/home/sven/code/nnMapper/build",
		"/home/sven/code/nnMapper/source",
		"/home/sven/code/nnMapper/source/cutils",
		"/home/sven/code/nnMapper/source/pythonInterface",
		"/home/sven/code/nnMapper/source/test"
	],
	"file_history":
	[
		"/home/sven/code/nnMapper/log.txt",
		"/home/sven/.bashrc",
		"/home/sven/code/nnMapper/source/cutils/key.h",
		"/home/sven/code/nnMapper/source/test/key_test.c",
		"/home/sven/Downloads/scatter3d_demo.py",
		"/home/sven/code/nnMapper/makefile",
		"/home/sven/code/installScript/silent.cfg",
		"/home/sven/code/Art_Repo/matlab/tools/generate_caffe_testing_files.m",
		"/home/sven/.zshrc",
		"/home/sven/code/nnMapper/source/pythonInterface/buildipCalculatorwrap.py",
		"/home/sven/code/installScript/mklInstall.sh",
		"/home/sven/code/installScript/mklInstall/mklInstall.sh",
		"/home/sven/code/installScript/sveninstall1.sh",
		"/home/sven/code/Art_Repo/python/generate_test.py",
		"/home/sven/code/Art_Repo/data/result/test1/net_test_categories.txt",
		"/home/sven/code/Art_Repo/data/EMonsonImageData/in_256_gray/cart_test_nolabel.txt",
		"/home/sven/code/Art_Repo/data/cifar10/get_cifar10.sh",
		"/home/sven/code/Art_Repo/matlab/tools/caffe_test.m",
		"/home/sven/code/tfAlexNet/myalexnet_forward.py",
		"/home/sven/code/tfAlexNet/caffe_classes.py",
		"/tmp/mozilla_sven0/myalexnet_forward.py",
		"/home/sven/Downloads/buttons.py",
		"/home/sven/code/nnMapper/source/cutils/nnLayerUtils.h",
		"/home/sven/code/nnMapper/nnMapper.sublime-project",
		"/home/sven/code/nnMapper/source/test/ipCalculator_test.py",
		"/home/sven/code/nnMapper/source/test/ipCalculator_test.c",
		"/home/sven/code/shuffleperiod.py",
		"/home/sven/bvlc.prototext",
		"/home/sven/code/nnMapper/source/cutils/nnLayerUtils.c",
		"/home/sven/code/nnMapper/source/cutils/ipCalculator.c",
		"/home/sven/code/nnMapper/source/utils/key.c",
		"/home/sven/code/nnMapper/source/utils/key.h",
		"/home/sven/code/nnMapper/source/cutils/key.c",
		"/home/sven/code/nnMapper/source/pythonInterface/buildnnLayerUtilsWrap.py",
		"/home/sven/code/nnMapper/source/pythonInterface/nnLayerUtilsWrap.pyx",
		"/home/sven/code/nnMapper/source/pythonInterface/ipCalculatorWrap.pyx",
		"/home/sven/code/nnMapper/source/test/parallelTree_test.c",
		"/home/sven/code/nnMapper/source/pythonInterface/ipCalculatorWrap.c",
		"/home/sven/code/nnMapper/source/utils/ipCalculator.h",
		"/home/sven/code/nnMapper/source/utils/ipCalculator.c",
		"/home/sven/code/nnMapper/source/test/buildipCalculatorwrap.py",
		"/home/sven/code/nnMapper/source/test/buildnnLayerUtilsWrap.py",
		"/home/sven/code/enryptclass.py",
		"/home/sven/code/nnMapper/source/pythonInterface/nnLayerUtils.pyx",
		"/home/sven/code/nnMapper/buildWrappers.py",
		"/home/sven/Downloads/gap4r8/bin/gap.sh",
		"/home/sven/code/personalSite/wordpress.txt",
		"/home/sven/code/autoRip.sh",
		"/home/sven/code/tfexperiments/rbm.py",
		"/home/sven/Documents/resume.pdf",
		"/home/sven/code/nnMapper/source/utils/linearAlgebra_test.c",
		"/home/sven/code/nnMapper/source/test/linAlg_test.c",
		"/home/sven/code/nnMapper/source/utils/linAlgMKL.c",
		"/home/sven/code/nnMapper/source/utils/linearAlgebra.h",
		"/home/sven/code/nnMapper/source/utils/linearAlgebra.c",
		"/home/sven/pfSense-udp-1194-sven/pfSense-udp-1194-sven.ovpn",
		"/media/sven/SIMON/readme.txt",
		"/home/sven/.abcde.conf",
		"/opt/intel/compilers_and_libraries_2017/linux/bin/compilervars.csh",
		"/opt/intel/compilers_and_libraries_2017/linux/bin/compilervars.sh",
		"/run/user/1000/gvfs/sftp:host=192.168.1.2,user=sven/home/sven/bulk/Videos/American History X [DVDRip]Eng[AC3 5.1] P2P4Life/b/post.txt",
		"/run/user/1000/gvfs/sftp:host=raffaello.duckdns.org,user=sven/home/sven/code/tfExperiments/grapher.py",
		"/run/user/1000/gvfs/sftp:host=davincileonardo.duckdns.org,user=sven/home/sven/tfexperiments/rbmMnistExperiment.py",
		"/home/sven/code/tfexperiments/tf2.py",
		"/home/sven/code/nnMapper/source/paralleltree.c",
		"/home/sven/code/nnMapper/source/paralleltree_test.h",
		"/home/sven/code/nnMapper/source/key_test.c",
		"/home/sven/code/nnMapper/source/paralleltree_test.c",
		"/home/sven/code/cs120-examples-f16/exercises/week6/pairwiseSum.c",
		"/run/user/1000/gvfs/sftp:host=192.168.1.2,user=sven/home/sven/code/installScript/sveninstall1.sh",
		"/home/sven/code/tensorflow/tensorflow/examples/tutorials/mnist/mnist_softmax.py",
		"/home/sven/code/tensorflow/tensorflow/examples/learn/mnist.py",
		"/home/sven/code/tensorflow/tensorflow/examples/learn/random_forest_mnist.py",
		"/home/sven/code/tensorflow/tensorflow/examples/learn/BUILD",
		"/home/sven/code/tensorflow/third_party/gpus/cuda/build_defs.bzl.tpl",
		"/run/user/1000/gvfs/sftp:host=davincileonardo.duckdns.org,user=sven/home/sven/tfexperiments/randomNormalParallel.py",
		"/home/sven/code/swig/example.hpp",
		"/home/sven/code/swig/example.pyc",
		"/media/sven/042A-8CB0/README.diskdefines",
		"/home/sven/Downloads/installScript/tfinstall.sh",
		"/media/sven/042A-8CB0/MMPackages/MM_Ubuntu_config .sh",
		"/home/sven/code/swig/useOfExample.py",
		"/home/sven/code/swig/example.py",
		"/home/sven/code/swig/example.swig"
	],
	"find":
	{
		"height": 32.0
	},
	"find_in_files":
	{
		"height": 80.0,
		"where_history":
		[
			"/home/sven/code/nnMapper"
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"printMatrix",
			"printFloat",
			"l2",
			"l1",
			"l0",
			"chromaSig",
			"cache",
			"Cache",
			"ipCache",
			"ipCalculator",
			"k",
			"while loop ",
			"ipSignatureRaw",
			"outDim",
			"key",
			"uint",
			"printFloat",
			"printf",
			"layer0->outDim",
			"cblas_scopy",
			"key",
			"cache->bases->keyLength",
			"utils",
			"uint",
			"3",
			"$(MKLROOT)",
			"WRAP ",
			"WRAP",
			"np",
			"$",
			"my_array",
			"DATASIZE",
			"double",
			"MKL_INT",
			"inDim",
			"parallelTree",
			"output",
			"paralleltree",
			"length",
			"key->dataLen",
			"length",
			"small",
			"double",
			"paralleltree",
			".",
			"I",
			"i",
			".key",
			"Int",
			"numElement",
			"unsigned",
			"paralleltree",
			"dataSize",
			"ret",
			"sizeof(unsigned char)",
			"j",
			"long int",
			"numToAdd",
			"range",
			"(node->bigNode)",
			"0x5420898",
			"big",
			"0x5420898",
			"big",
			"0x5420898",
			"big",
			"tree",
			"Tree",
			"tree",
			"Tree",
			"tree",
			"data",
			"randArr",
			"dataStruct",
			"data",
			"total",
			"dataInput",
			"keyAddThreadArgs",
			"vector",
			"Vector",
			"vector",
			"Vector",
			"vector",
			"Vector",
			"vector",
			"Vector",
			"vector",
			"Vector",
			"vector",
			"spinlock_init",
			"spinlock_destroy",
			"spinlock_unlock",
			"spinlock_lock",
			"Mutex",
			"mutex",
			"Mutex",
			"mutex",
			"Mutex",
			"mutex",
			"Mutex",
			"mutex",
			"Mutex",
			"mutex",
			"Mutex",
			"mutex",
			"Mutex",
			"mutex",
			"Mutex",
			"mutex",
			"Mutex",
			"mutex",
			"Mutex",
			"mutex",
			"Mutex",
			"mutex",
			"tree",
			"big",
			"node->bigNode",
			"node",
			"0x5422770",
			"0x54222c0",
			"0x54225e0",
			"*node",
			"*parentNode",
			"(*parentNode",
			"*parentNode",
			"0x5422158",
			"0x5421108"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "source/cutils/ipCalculator.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 667,
						"regions":
						{
						},
						"selection":
						[
							[
								273,
								273
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 13,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "source/cutils/ipCalculator.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14142,
						"regions":
						{
						},
						"selection":
						[
							[
								1172,
								1172
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 336.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "log.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 593592,
						"regions":
						{
						},
						"selection":
						[
							[
								593568,
								593571
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 135387.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "source/test/mapper_test.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2871,
						"regions":
						{
						},
						"selection":
						[
							[
								2570,
								2570
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 756.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "source/pythonInterface/buildMapperWrap.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1326,
						"regions":
						{
						},
						"selection":
						[
							[
								1175,
								1175
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "source/cutils/mapper.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 986,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "source/cutils/mapper.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6612,
						"regions":
						{
						},
						"selection":
						[
							[
								2169,
								2169
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 805.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "source/cutils/parallelTree.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5093,
						"regions":
						{
						},
						"selection":
						[
							[
								5089,
								5089
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 2040.0,
						"zoom_level": 1.0
					},
					"stack_index": 12,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "source/cutils/key.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3132,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 416.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "source/test/ipCalculator_test.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2047,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "makefile",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2726,
						"regions":
						{
						},
						"selection":
						[
							[
								1876,
								1876
							]
						],
						"settings":
						{
							"syntax": "Packages/Makefile/Makefile.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 336.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "source/pythonInterface/keyWrap.pyx",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1603,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Cython/Cython.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 12,
					"file": "source/pythonInterface/ipCalculatorWrap.pyx",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4459,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Cython/Cython.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 28.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 13,
					"file": "source/cutils/nnLayerUtils.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1701,
						"regions":
						{
						},
						"selection":
						[
							[
								1135,
								1135
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 420.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 22.0
	},
	"input":
	{
		"height": 31.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 272.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.latextools":
	{
		"height": 100.0
	},
	"pinned_build_system": "",
	"project": "nnMapper.sublime-project",
	"replace":
	{
		"height": 40.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 184.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
